/**
  \page tutorial-ukf Tutorial: Using Unscented Kalman Filter to filter your data
  \tableofcontents

\section tuto-ukf-intro Introduction

The Unscented Kalman Filter (UKF) is a version of the Kalman filter that handles non-linearities.

In this tutorial, we will use a UKF to filter the 3D position of a simulated object, which revolves in a plane parallel
to the ground around a static point, which is the origin of the world frame \f$ \mathcal{F}_W \f$. The coordinate frame
attached to the object is denoted \f$ \mathcal{F}_O \f$. The object is observed by a static camera whose coordinate
frame is denoted \f$ \mathcal{F}_C \f$. The object is supposed plane and having four markers sticked on its surface.

The equations that describe the motion of the object in the world frame are the following:

\f{eqnarray*}{
  {}^W \textbf{X}_x &=& R cos(\omega t + \phi) \\
  {}^W \textbf{X}_y &=& R sin(\omega t + \phi) \\
  {}^W \textbf{X}_z &=& constant
\f}

\htmlonly <style>div.image img[src="img-tutorial-ukf-illustration.jpg"]{width:50%;}</style> \endhtmlonly
\image html img-tutorial-ukf-illustration.jpg

\subsection tuto-ukf-intro-methods The maths beyond the Unscented Kalman Filter

The maths beyond the Unscented Kalman Filter are explained in the documentation of the vpUnscentedKalman class.
We will recall briefly the important steps of the UKF.

Be \f$ \textbf{x} \in \mathcal{R}^n \f$ the internal state of the UKF and \f$ \textbf{P} \in \mathcal{R}^{n x n} \f$ the
associated covariance matrix.

The first step of the UKF is the prediction step. During this step, some particular points called sigma points and denoted
\f$ \chi \f$ are drawn, along with associated weights \f$ \textbf{w}^m \f$ for the computation of the mean and \f$ \textbf{w}^c \f$
for the computation of the covariance:

\f{eqnarray*}{
  \chi &=& sigma-function(\textbf{x}, \textbf{P}) \\
  \textbf{w}^m, \textbf{w}^c &=& weight-function(n, parameters)
\f}

There are different ways of drawing the sigma points and associated weights in the litterature, such as the one
proposed by Julier or the one proposed by E. A. Wan and R. van der Merwe.

Then, we pass each sigma point through the process function \f$ f(\chi, \Delta t) \f$, the command function
\f$b( \textbf{u}, \Delta t )\f$ and the command function depending on the state \f$bx( \textbf{u}, \chi, \Delta t )\f$
to project them forward in time, forming the new prior:

\f$ \mathcal{Y} = f( \chi , \Delta t ) + b( \textbf{u}, \Delta t ) + bx( \textbf{u}, \chi, \Delta t )  \f$

Finally, we apply the Unscented Transform to compute the mean \f$ \boldsymbol{\mu} \f$
and covariance \f$ \overline{\textbf{P}} \f$ of the prior:

\f{eqnarray*}{
    \boldsymbol{\mu},  \overline{\textbf{P}} &=& UT(\mathcal{Y}, \textbf{w}^m, \textbf{w}^c, \textbf{Q}) \\
    \boldsymbol{\mu} &=& \sum_{i=0}^{2n} w_i^m \mathcal{Y}_i \\
    \overline{\textbf{P}} &=& \sum_{i=0}^{2n} ( w_i^c (\mathcal{Y}_i - \boldsymbol{\mu}) (\mathcal{Y}_i - \boldsymbol{\mu})^T ) + \textbf{Q}
 \f}

where \f$ \textbf{Q} \f$ is the covariance of the error introduced by the process function.

The second step of the UKF is to update the internal state based on new measurements. It is performed in the measurement space, so we must convert the sigma points of
the prior into measurements using the measurement function  \f$ h: \mathcal{R}^n \rightarrow \mathcal{R}^m \f$:

\f$ \mathcal{Z} = h(\mathcal{Y}) \f$

Then, we use once again the Unscented Transform to compute the mean \f$ \boldsymbol{\mu}_z \in \mathcal{R}^m \f$ and the
covariance \f$ \textbf{P}_z \in \mathcal{R}^{m x m} \f$ of these points:

\f{eqnarray*}{
    \boldsymbol{\mu}_z,  \textbf{P}_z &=& UT(\mathcal{Z}, \textbf{w}^m, \textbf{w}^c, \textbf{R}) \\
    \boldsymbol{\mu}_z &=& \sum_{i=0}^{2n} w_i^m \mathcal{Z}_i \\
    \textbf{P}_z &=& \sum_{i=0}^{2n} ( w_i^c (\mathcal{Z}_i - \boldsymbol{\mu}_z) (\mathcal{Z}_i - \boldsymbol{\mu}_z)^T ) + \textbf{R}
\f}

where \f$ \textbf{R} \f$ is the measurement covariance matrix.

Then, we compute the residual \f$ \textbf{y} \f$ of the measurement \f$ \textbf{z} \f$:

\f$ \textbf{Y} = \textbf{z} - \boldsymbol{\mu}_z \f$

To compute the Kalman's gain, we first need to compute the cross covariance of the state and the measurements:

\f$ \textbf{P}_{xy} = \sum_{i=0}^{2n} w_i^c (\mathcal{Y}_i - \boldsymbol{\mu})(\mathcal{Z}_i - \boldsymbol{\mu}_z)^T \f$

The Kalman's gain is then defined as:

\f$ \textbf{K} = \textbf{P}_{xz} \textbf{P}_z^{-1} \f$

Finally, we can compute the new state estimate \f$ \textbf{x} \f$ and the new covariance \f$ \textbf{P} \f$:

\f{eqnarray*}{
 \textbf{x} &=& \boldsymbol{\mu} + \textbf{K} \textbf{y} \\
 \textbf{P} &=& \overline{\textbf{P}} - \textbf{K} \textbf{P}_z \textbf{K}^T
\f}

\section tuto-ukf-tutorial Explanations about the tutorial

\subsection tuto-ukf-tutorial-howtorun How to run the tutorial

To run the tutorial, please run the following commands:

```
$ cd $VISP_WS/visp-build/tutorial/kalman
$ ./tutorial-ukf
```

The program does not take any argument. You should see something similar to the following image:

\htmlonly <style>div.image img[src="img-tutorial-ukf-run.jpg"]{width:50%;}</style> \endhtmlonly
\image html img-tutorial-ukf-run.jpg "Screenshot of the tutorial Graphical User Interface"

Press `Return` to leave the program.

\subsection tuto-ukf-tutorial-explained Detailed explanations about the UKF tutorial

For this tutorial, we use the main program tutorial-ukf.cpp . The internal state of the UKF is
the 3D pose of the object expressed in the world frame, along with the pulsation \f$ \omega \f$ of the motion:

\f{eqnarray*}{
  \textbf{x}[0] &=& {}^WX_x \\
  \textbf{x}[1] &=& {}^WX_y \\
  \textbf{x}[2] &=& {}^WX_z \\
  \textbf{x}[3] &=& \omega \Delta t
\f}

The measurement \f$ \textbf{z} \f$ corresponds to the perspective projection of the different markers in the image.
Be \f$ u_i \f$ and \f$ v_i \f$ the horizontal and vertical pixel coordinates of the \f$ i^{th} \f$ marker.
The measurement vector can be written as:

\f{eqnarray*}{
  \textbf{z}[2i] &=& u_i \\
  \textbf{z}[2i+1] &=& v_i
\f}

Be \f$ \textbf{K}_{intr} \f$ the camera instrinsic parameters matrix defined by:

\f$ \textbf{K}_{intr} = \begin{pmatrix}
  p_x & 0   & u_0 \\
  0   & p_y & v_0 \\
  0   & 0   & 1
  \end{pmatrix}
\f$

where \f$ (u_0, v0, 1)^T \f$ are the coordinates of the principal point and \f$ p_x \f$ (resp. \f$ p_y \f$) is the ratio
between the focal lens of the camera and the width (resp. height) of a pixel.

Be \f$ \boldsymbol{\pi} \f$ the projection matrix  that is, in the case of a perspective
projection model, given by:

\f$ \boldsymbol{\pi} = \begin{pmatrix}
  1 & 0 & 0 & 0 \\
  0 & 1 & 0 & 0 \\
  0 & 0 & 1 & 0
  \end{pmatrix}
\f$

The perspective projection \f$ \textbf{p} = (u, v, 1)^T \f$ of a point \f$ {}^W\textbf{X} = ({}^WX_x, {}^WX_y, {}^WX_z, 1)^T \f$
is given by:

\f$ \textbf{p} = \textbf{K}_{intr} \boldsymbol{\pi} {}^C\textbf{M}_W {}^W\textbf{X} \f$

where \f$ {}^C\textbf{M}_W \f$ is the homogeneous matrix that expresses the pose of the world coordinate frame \f$ \mathcal{F}_W \f$
with regard to the camera frame \f$ \mathcal{F}_C \f$.

\subsubsection tuto-ukf-tutorial-explained-includes Details on the includes

To have a Graphical User Interface (GUI), we include the following files.

\snippet tutorial-ukf.cpp Display_includes

To be able to use the UKF, we use the following includes:

\snippet tutorial-ukf.cpp UKF_includes

\subsubsection tuto-ukf-tutorial-explained-plate Details on the class simulating a moving object

To make simpler the main loop of the program, we decided to implement a class for updating the 3D position
of the object, expressed in the world frame, in a dedicated class.

\snippet tutorial-ukf.cpp Object_simulator

\subsubsection tuto-ukf-tutorial-explained-fx Details on the process function

As mentionned before, the UKF relies on a process function which project in time the internal state of the UKF.

We want to express the internal state projected in the future \f$ \textbf{x}_{t + \Delta t} \f$ as a function of its
previous state \f$ \textbf{x}_{t} \f$.

As stated in the introduction, the equations of motion of the object are the following:

\f{eqnarray*}{
  {}^W \textbf{X}_x(t) &=& R cos(\omega t + \phi) \\
  {}^W \textbf{X}_y(t) &=& R sin(\omega t + \phi) \\
  {}^W \textbf{X}_z(t) &=& constant
\f}

Thus, we have:

\f{eqnarray*}{
  {}^WX_x( t + \Delta t) &=& R cos(\omega (t + \Delta t) + \phi) &=& R cos((\omega t + \phi) + \omega \Delta t )\\
  {}^WX_y( t + \Delta t) &=& R sin(\omega (t + \Delta t) + \phi) &=& R sin((\omega t + \phi) + \omega \Delta t )\\
  {}^WX_z( t + \Delta t) &=& constant
\f}

Which can be rewritten:
\f{eqnarray*}{
  {}^WX_x( t + \Delta t) &=& R cos((\omega t + \phi) + \omega \Delta t ) &=& R cos(\omega t + \phi) cos (\omega \Delta t ) - R sin(\omega t + \phi) sin(\omega \Delta t) \\
  {}^WX_y( t + \Delta t) &=& R sin((\omega t + \phi) + \omega \Delta t ) &=& R cos(\omega t + \phi) sin (\omega \Delta t ) + R sin(\omega t + \phi) cos(\omega \Delta t)\\
  {}^WX_z( t + \Delta t) &=& constant
\f}

And can be finally written as:
\f{eqnarray*}{
  {}^WX_x( t + \Delta t) &=& R cos(\omega t + \phi) cos (\omega \Delta t ) - R sin(\omega t + \phi) sin(\omega \Delta t) &=& {}^W \textbf{X}_x( t) cos(\omega \Delta t) - {}^W \textbf{X}_y(t) sin(\omega \Delta t) \\
  {}^WX_y( t + \Delta t) &=& R cos(\omega t + \phi) sin (\omega \Delta t ) + R sin(\omega t + \phi) cos(\omega \Delta t) &=& {}^W \textbf{X}_x( t) sin(\omega \Delta t) + {}^W \textbf{X}_y(t) cos(\omega \Delta t) \\
  {}^WX_z( t + \Delta t) &=& constant
\f}

This motivates us to choose the following non-linear process function:

\f{eqnarray*}{
  \textbf{x}[0]_{t + \Delta t} &=& {}^WX_x (t + \Delta t) &=& \textbf{x}[0]_{t} cos(\textbf{x}[3]_{t}) - \textbf{x}[1]_{t} sin(\textbf{x}[3]_{t}) \\
  \textbf{x}[1]_{t + \Delta t} &=& {}^WX_y (t + \Delta t) &=& \textbf{x}[0]_{t} sin(\textbf{x}[3]_{t}) + \textbf{x}[1]_{t} cos(\textbf{x}[3]_{t}) \\
  \textbf{x}[2]_{t + \Delta t} &=& {}^WX_z (t + \Delta t) &=& \textbf{x}[2]_{t} \\
  \textbf{x}[3]_{t + \Delta t} &=& \omega \Delta t &=& \textbf{x}[3]_{t}
\f}

As the process function is pretty simple, a simple function called here fx is enough:

\snippet tutorial-ukf.cpp Process_function

\subsubsection tuto-ukf-tutorial-explained-markers Details on the class simulating marker measurement

\snippet tutorial-ukf.cpp Markers_class

\snippet tutorial-ukf.cpp Measurement_function

\snippet tutorial-ukf.cpp GT_measurements

\snippet tutorial-ukf.cpp Noisy_measurements

\subsubsection tuto-ukf-tutorial-explained-pose Details on the computation of the pose from noisy measurements

\snippet tutorial-ukf.cpp Pose_for_display

\subsubsection tuto-ukf-tutorial-explained-constants Details on the constants of the main loop

\snippet tutorial-ukf.cpp Constants_for_simulation

\snippet tutorial-ukf.cpp Camera_for_measurements

\subsubsection tuto-ukf-tutorial-explained-initukf Details on the initialization of the UKF

\snippet tutorial-ukf.cpp Sigma_points_drawer

\snippet tutorial-ukf.cpp Covariance_measurements

\snippet tutorial-ukf.cpp Covariance_process

\snippet tutorial-ukf.cpp Initial_estimates

\snippet tutorial-ukf.cpp Init_functions

\snippet tutorial-ukf.cpp Init_UKF

\subsubsection tuto-ukf-tutorial-explained-initgui Details on the initialization of the Graphical User Interface

\snippet tutorial-ukf.cpp Init_plot

\snippet tutorial-ukf.cpp Init_renderer

\subsubsection tuto-ukf-tutorial-explained-initloop Details on the initialization of the loop

\snippet tutorial-ukf.cpp Init_simu

\subsubsection tuto-ukf-tutorial-explained-loop Details on the loop

\snippet tutorial-ukf.cpp Simu_loop

\snippet tutorial-ukf.cpp Update_simu

\snippet tutorial-ukf.cpp Update_measurement

\snippet tutorial-ukf.cpp Perform_filtering

\snippet tutorial-ukf.cpp Update_displays

\snippet tutorial-ukf.cpp Noisy_pose

\snippet tutorial-ukf.cpp Update_plot

\snippet tutorial-ukf.cpp Update_renderer

\subsubsection tuto-ukf-tutorial-explained-cleaning Details on the cleaning at the end of the program

\snippet tutorial-ukf.cpp Delete_renderer

The program stops once the `Return` key is pressed.
*/
